// Generated by CoffeeScript 1.9.3
(function() {
  var Q, R, argmax, buildGridworld, init, lightUpCurrState, pickState, randChoice, setColor, setupVisualizer, updateQ;

  setColor = function(el, reward) {
    if (reward < 0) {
      return el.style.backgroundColor = "hsl(0,100%," + (100 - Math.min(-reward, 70)) + "%)";
    } else {
      return el.style.backgroundColor = "hsl(100,100%," + (100 - Math.min(reward, 70)) + "%)";
    }
  };

  setupVisualizer = function() {
    var d, i, k, len, ref, row, s, trow;
    row = '0';
    trow = document.createElement('div');
    trow.classList.add('trow');
    ref = Object.keys(states);
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      s = states[k];
      d = document.createElement('div');
      d.id = String(s.id);
      d.classList.add('cell');
      d.innerHTML = String("<div>" + (Math.floor(s.Q[argmax(s.Q)])) + "</div>");
      d.onclick = function(e) {
        var state;
        state = window.states[e.path[1].id];
        console.log(state);
        if (e.shiftKey) {
          state.reward -= 10;
        } else {
          state.reward += 10;
        }
        return setColor(e.path[1], state.reward);
      };
      setColor(d, s.reward);
      if (s.id[0] === row) {
        trow.appendChild(d);
      } else {
        document.getElementById('content').appendChild(trow);
        row = s.id[0];
        trow = document.createElement('div');
        trow.classList.add('trow');
        trow.appendChild(d);
      }
    }
    return document.getElementById('content').appendChild(trow);
  };

  lightUpCurrState = function(prev, state) {
    var curr, old;
    old = document.getElementById(prev.id);
    curr = document.getElementById(state.id);
    setColor(old, prev.reward);
    old.classList.remove('active');
    curr.classList.add('active');
    return curr.innerHTML = String("<div>" + (Math.floor(state.Q[argmax(state.Q)])) + "</div>");
  };

  buildGridworld = function(x, y) {
    var buildStateActions, col, i, j, ref, ref1, ref2, row, state, states;
    states = {};
    buildStateActions = function(row, col, x, y) {
      var Q, actions;
      actions = {};
      Q = {};
      if (row - 1 >= 0) {
        actions.up = (row - 1) + "-" + col;
        Q.up = 0;
      }
      if (row + 1 < x) {
        actions.down = (row + 1) + "-" + col;
        Q.down = 0;
      }
      if (col - 1 >= 0) {
        actions.left = row + "-" + (col - 1);
        Q.left = 0;
      }
      if (col + 1 < y) {
        actions.right = row + "-" + (col + 1);
        Q.right = 0;
      }
      return [actions, Q];
    };
    for (row = i = 0, ref = x; 0 <= ref ? i < ref : i > ref; row = 0 <= ref ? ++i : --i) {
      for (col = j = 0, ref1 = y; 0 <= ref1 ? j < ref1 : j > ref1; col = 0 <= ref1 ? ++j : --j) {
        state = {};
        state.id = row + "-" + col;
        ref2 = buildStateActions(row, col, x, y), state.actions = ref2[0], state.Q = ref2[1];
        state.reward = -(Math.random() * 10);
        if (Math.random() <= 0.25) {
          state.reward = state.reward = -100;
        }
        if (row === x - 1 && col === y - 1) {
          state.reward = 70;
        }
        states[state.id] = state;
      }
    }
    return states;
  };

  argmax = function(obj) {
    var bestKey, bestKeys, k, v;
    bestKey = Object.keys(obj)[0];
    for (k in obj) {
      v = obj[k];
      if (v >= obj[bestKey]) {
        bestKey = k;
      }
    }
    bestKeys = [];
    for (k in obj) {
      v = obj[k];
      if (v === obj[bestKey]) {
        bestKeys.push(k);
      }
    }
    return randChoice(bestKeys);
  };

  randChoice = function(arr) {
    if (!Array.isArray(arr)) {
      arr = Object.keys(arr);
    }
    return arr[Math.floor(Math.random() * arr.length)];
  };

  R = function(state, action) {
    return states[state.actions[action]].reward;
  };

  Q = function(state, action) {
    return state.Q[action];
  };

  updateQ = function(state, sprime, action) {
    var actprime, bestQ, testq;
    bestQ = -Infinity;
    for (actprime in sprime.actions) {
      testq = Q(sprime, actprime) - Q(state, action);
      if (testq >= bestQ) {
        bestQ = testq;
      }
    }
    return state.Q[action] += lrate * (R(state, action) + discount * bestQ);
  };

  pickState = function(state) {
    var aB, aR, bestId, randId;
    if (Math.random() <= 0.95) {
      aB = argmax(state.Q);
      bestId = state.actions[aB];
      return [states[bestId], aB];
    } else {
      aR = randChoice(state.actions);
      randId = state.actions[aR];
      return [states[randId], aR];
    }
  };

  window.runVisualization = function() {
    var e, lastStep, prevState, step, t;
    e = 0;
    t = 0;
    lastStep = false;
    prevState = states['0-0'];
    step = function() {
      var a, ref, s, tempS;
      if (lastStep || prevState.reward >= 70) {
        lastStep = false;
        tempS = prevState;
        prevState = states['0-0'];
        lightUpCurrState(tempS, prevState);
      }
      ref = pickState(prevState), s = ref[0], a = ref[1];
      updateQ(prevState, s, a);
      lightUpCurrState(prevState, s);
      prevState = s;
      return setTimeout(step, 100);
    };
    window.advanceEpoch = function() {
      e++;
      return lastStep = true;
    };
    return step();
  };

  init = function() {
    window.states = buildGridworld(6, 6);
    window.lrate = 0.1;
    window.discount = 0.5;
    return setupVisualizer();
  };

  init();

}).call(this);
