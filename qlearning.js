// Generated by CoffeeScript 1.9.3
(function() {
  var Q, R, argmax, buildGridworld, init, lightUpCurrState, pickState, randChoice, setColor, setupVisualizer, updateQ;

  setColor = function(el, reward) {
    if (reward < 0) {
      return el.style.backgroundColor = "hsl(0,100%," + (100 - Math.min(-reward, 70)) + "%)";
    } else {
      return el.style.backgroundColor = "hsl(100,100%," + (100 - Math.min(reward, 70)) + "%)";
    }
  };

  setupVisualizer = function() {
    var d, j, k, len, ref, row, s, trow;
    row = '0';
    trow = document.createElement('div');
    trow.classList.add('trow');
    ref = Object.keys(states);
    for (j = 0, len = ref.length; j < len; j++) {
      k = ref[j];
      s = states[k];
      d = document.createElement('div');
      d.id = String(s.id);
      d.classList.add('cell');
      d.innerHTML = String("<div>" + (Math.floor(s.Q[argmax(s.Q)])) + "</div>");
      d.onclick = function(e) {
        var state;
        state = window.states[e.path[1].id];
        console.log(state);
        if (e.shiftKey) {
          state.reward -= 10;
        } else {
          state.reward += 10;
        }
        return setColor(e.path[1], state.reward);
      };
      setColor(d, s.reward);
      if (s.id[0] === row) {
        trow.appendChild(d);
      } else {
        document.getElementById('content').appendChild(trow);
        row = s.id[0];
        trow = document.createElement('div');
        trow.classList.add('trow');
        trow.appendChild(d);
      }
    }
    return document.getElementById('content').appendChild(trow);
  };

  lightUpCurrState = function(prev, state) {
    var curr, old;
    old = document.getElementById(prev.id);
    curr = document.getElementById(state.id);
    setColor(old, prev.reward);
    old.classList.remove('active');
    curr.classList.add('active');
    return curr.innerHTML = String("<div>" + (Math.floor(state.Q[argmax(state.Q)])) + "</div>");
  };

  buildGridworld = function(x, y) {
    var _, buildStateActions, col, j, l, ref, ref1, row, state, states;
    states = {};
    buildStateActions = function(row, col, x, y) {
      var actions;
      actions = [];
      if (row - 1 >= 0) {
        actions.push((row - 1) + "-" + col);
      }
      if (row + 1 < x) {
        actions.push((row + 1) + "-" + col);
      }
      if (col - 1 >= 0) {
        actions.push(row + "-" + (col - 1));
      }
      if (col + 1 < y) {
        actions.push(row + "-" + (col + 1));
      }
      return actions;
    };
    for (row = j = 0, ref = x; 0 <= ref ? j < ref : j > ref; row = 0 <= ref ? ++j : --j) {
      for (col = l = 0, ref1 = y; 0 <= ref1 ? l < ref1 : l > ref1; col = 0 <= ref1 ? ++l : --l) {
        state = {};
        state.id = row + "-" + col;
        state.actions = buildStateActions(row, col, x, y);
        state.Q = (function() {
          var len, m, ref2, results;
          ref2 = state.actions;
          results = [];
          for (m = 0, len = ref2.length; m < len; m++) {
            _ = ref2[m];
            results.push(0);
          }
          return results;
        })();
        state.reward = Math.floor(Math.random() * 50);
        if (Math.random() <= 0.5) {
          state.reward = -state.reward;
        }
        states[state.id] = state;
      }
    }
    return states;
  };

  argmax = function(arr) {
    var _, bestInd, bestInds, i, j, l, len, len1, val;
    bestInd = 0;
    for (i = j = 0, len = arr.length; j < len; i = ++j) {
      _ = arr[i];
      if (arr[i] > bestInd) {
        bestInd = i;
      }
    }
    bestInds = [];
    for (i = l = 0, len1 = arr.length; l < len1; i = ++l) {
      val = arr[i];
      if (val === arr[bestInd]) {
        bestInds.push(i);
      }
    }
    return randChoice(bestInds);
  };

  randChoice = function(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  };

  R = function(state, action) {
    return states[state.actions[action]].reward;
  };

  Q = function(state, action) {
    return state.Q[action];
  };

  updateQ = function(state, sprime, action) {
    var _, _q, a, bestQ, j, len, ref;
    bestQ = -Infinity;
    ref = sprime.actions;
    for (a = j = 0, len = ref.length; j < len; a = ++j) {
      _ = ref[a];
      _q = Q(sprime, a) - Q(state, action);
      if (_q >= bestQ) {
        bestQ = _q;
      }
    }
    return state.Q[action] += lrate * (R(state, action) + discount * bestQ);
  };

  pickState = function(state) {
    var aB, aR, bestId, randId;
    if (Math.random() <= 0.95) {
      aB = argmax(state.Q);
      bestId = state.actions[aB];
      return [states[bestId], aB];
    } else {
      aR = Math.floor(Math.random() * state.actions.length);
      randId = state.actions[aR];
      return [states[randId], aR];
    }
  };

  window.runVisualization = function() {
    var e, lastStep, prevState, step, t;
    e = 0;
    t = 0;
    lastStep = false;
    prevState = states['0-0'];
    step = function() {
      var a, ref, s, tempS;
      if (lastStep) {
        lastStep = false;
        tempS = prevState;
        prevState = states['0-0'];
        lightUpCurrState(tempS, prevState);
      }
      ref = pickState(prevState), s = ref[0], a = ref[1];
      updateQ(prevState, s, a);
      lightUpCurrState(prevState, s);
      prevState = s;
      return setTimeout(step, 200);
    };
    window.advanceEpoch = function() {
      e++;
      return lastStep = true;
    };
    return step();
  };

  init = function() {
    window.states = buildGridworld(5, 5);
    window.lrate = 0.1;
    window.discount = 0.5;
    return setupVisualizer();
  };

  init();

}).call(this);
